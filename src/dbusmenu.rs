// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

//! A library to allow applications to provide simple indications of
//! information to be displayed to users of the application through the
//! interface shell.
//!
//! The goal of DBusMenu is to expose menus on DBus.
//!
//! ```
//! Copyright 2009 Canonical Ltd.
//!
//! Authors:
//! Ted Gould <ted@canonical.com>
//! Aurélien Gâteau <aurelien.gateau@canonical.com>
//!
//! This program is free software: you can redistribute it and/or modify it
//! under the terms of either or both of the following licenses:
//!
//! 1) the GNU Lesser General Public License version 3, as published by the
//! Free Software Foundation; and/or
//! 2) the GNU Lesser General Public License version 2.1, as published by
//! the Free Software Foundation.
//!
//! This program is distributed in the hope that it will be useful, but
//! WITHOUT ANY WARRANTY; without even the implied warranties of
//! MERCHANTABILITY, SATISFACTORY QUALITY or FITNESS FOR A PARTICULAR
//! PURPOSE.  See the applicable version of the GNU Lesser General Public
//! License for more details.
//!
//! You should have received a copy of both the GNU Lesser General Public
//! License version 3 and version 2.1 along with this program.  If not, see
//! <http://www.gnu.org/licenses/>
//! ```
//!

#![allow(dead_code)]
use dbus as dbus;
use dbus::arg;
use dbus::tree;

/// A DBus interface to expose menus on DBus.
///
/// Menu items are represented with a unique numeric id and a dictionary of
/// properties.
///
/// To reduce the amount of DBus traffic, a property should only be returned
/// if its value is not the default value.
///
/// Available properties are:
///
/// <table>
/// <tr>
///     <th>Name</th>
///     <th>Type</th>
///     <th>Description</th>
///     <th>Default Value</th>
/// </tr>
/// <tr>
///     <td>type</td>
///     <td>String</td>
///     <td>Can be one of:
///
///      - "standard": an item which can be clicked to trigger an action or
///         show another menu
///      - "separator": a separator
///
/// Vendor specific types can be added by prefixing them with
/// "x-<vendor>-".
///
/// </td>
///     <td>"standard"</td>
/// </tr>
/// <tr>
///     <td>label</td>
///     <td>string</td>
///     <td>Text of the item, except that:
///
///         <ul>
///             <li>two consecutive underscore characters "__" are displayed as a single underscore,</li>
///             <li>any remaining underscore characters are not displayed at all</li>
///             <li> the first of those remaining underscore characters (unless it is
///                  the last character in the string) indicates that the following
///                   character is the access key.
///             </li>
///         </ul>
///     </td>
///     <td>""</td>
/// </tr>
/// <tr>
///     <td>enabled</td>
///     <td>boolean</td>
///     <td>Whether the item can be activated or not.</td>
///     <td>true</td>
/// </tr>
/// <tr>
///     <td>visible</td>
///     <td>boolean</td>
///     <td>True if the item is visible in the menu.</td>
///     <td>true</td>
/// </tr>
/// <tr>
///     <td>icon-name</td>
///     <td>string</td>
///     <td>Icon name of the item, following the freedesktop.org icon spec.</td>
///     <td>""</td>
/// </tr>
/// <tr>
///     <td>icon-data</td>
///     <td>binary</td>
///     <td>PNG data of the icon.</td>
///     <td>Empty</td>
/// </tr>
/// <tr>
///     <td>shortcut</td>
///     <td>array of arrays of strings</td>
///     <td>
///
///     The shortcut of the item. Each array represents the key press
///     in the list of keypresses. Each list of strings contains a list of
///     modifiers and then the key that is used. The modifier strings
///     allowed are: "Control", "Alt", "Shift" and "Super".
///
///         <ul>
///             <li>A simple shortcut like Ctrl+S is represented as: `[["Control", "S"]]`</li>
///             <li>A complex shortcut like Ctrl+Q, Alt+X is represented as: `[["Control", "Q"], ["Alt", "X"]]`</li>
///         </ul>
///     </td>
///     <td>Empty</td>
/// </tr>
/// <tr>
///     <td>toggle-type</td>
///     <td>string</td>
///     <td>
///         If the item can be toggled, this property should be set to:
///
///         <ul>
///             <li>"checkmark": Item is an independent togglable item</li>
///             <li>"radio": Item is part of a group where only one item can be toggled at a time</li>
///             <li>"": Item cannot be toggled</li>
///         </ul>
///     </td>
///     <td>""</td>
/// </tr>
/// <tr>
///     <td>toggle-state</td>
///     <td>int</td>
///     <td>
///         Describe the current state of a "togglable" item. Can be one of:
///
///         <ul>
///             <li>0 = off</li>
///             <li>1 = on</li>
///             <li>anything else = indeterminate</li>
///         </ul>
///
///         Note:
///         The implementation does not itself handle ensuring that only one
///         item in a radio group is set to "on", or that a group does not have
///         "on" and "indeterminate" items simultaneously; maintaining this
///         policy is up to the toolkit wrappers.
///     </td>
///     <td>-1</td>
/// </tr>
/// <tr>
///     <td>children-display</td>
///     <td>string</td>
///     <td>If the menu item has children this property should be set to "submenu".</td>
///     <td>""</td>
/// </tr>
/// </table>
///
/// Vendor specific properties can be added by prefixing them with `x-<vendor>-`
pub trait ComCanonicalDbusmenu {

    type Err;

    // ----------- FUNCTIONS

    /// Provides the layout and propertiers that are attached to the entries
    /// that are in the layout.  It only gives the items that are children
    /// of the item that is specified in @a parentId.  It will return all of the
    /// properties or specific ones depending of the value in @a propertyNames.
    ///
    /// The format is recursive, where the second 'v' is in the same format
    /// as the original 'a(ia{sv}av)'.  Its content depends on the value
    /// of @a recursionDepth.
    ///
    /// ### Inputs
    ///
    /// - `parent_id`: The ID of the parent node for the layout.  For grabbing the layout from the root node use zero.
    /// - `recursion_depth`: The amount of levels of recursion to use.  This affects the content of the second variant array.
    ///      - -1: deliver all the items under the @a parentId.
    ///      - 0: no recursion, the array will be empty.
    ///      - n: array will contains items up to 'n' level depth.
    /// - `property_names`: The list of item properties we are interested in. If there are no entries in the list all of the properties will be sent.
    ///
    /// ### Outputs
    ///
    /// - `revision: i32`: The revision number of the layout.  For matching with layoutUpdated signals.
    /// - `layout: HashMap`: The layout, as a recursive structure.
    ///
    fn get_layout(&self, parent_id: i32, recursion_depth: i32, property_names: Vec<&str>) -> Result<(u32, (i32, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>, Vec<arg::Variant<Box<arg::RefArg>>>)), Self::Err>;

    /// Returns the list of items which are children of @a parentId.
    ///
    /// ### Inputs
    ///
    /// - `ids`: A list of ids that we should be finding the properties on. If the list is empty, all menu items should be sent.
    /// - `property_names`: The list of item properties we are interested in. If there are no entries in the list all of the properties will be sent.
    ///
    /// ### Outputs
    ///
    /// - `properties: Vec`: An array of property values. An item in this area is represented as a struct following this format:
    ///     - `id` - unsigned the item id
    ///     - `properties` - map(string => variant) the requested item properties
    ///
    fn get_group_properties(&self, ids: Vec<i32>, property_names: Vec<&str>) -> Result<Vec<(i32, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)>, Self::Err>;

    /// Get a signal property on a single item.  This is not useful if you're
    /// going to implement this interface, it should only be used if you're
    /// debugging via a commandline tool.
    ///
    /// ### Inputs
    ///
    /// - `id`: the id of the item which received the event
    /// - `name`: the id of the item which received the event
    ///
    /// ### Outputs
    ///
    /// - `value: Variant`: the value of the property
    ///
    fn get_property(&self, id: i32, name: &str) -> Result<arg::Variant<Box<arg::RefArg>>, Self::Err>;

    /// This is called by the applet to notify the application an event happened on a menu item.
    /// The type can be one of the following:
    ///
    /// - `clicked`
    /// - `hovered`
    ///
    /// Vendor specific events can be added by prefixing them with `x-<vendor>-`
    ///
    /// ### Inputs
    ///
    /// - `id`: the id of the item which received the event
    /// - `event_id`: the type of event
    /// - `data`: event-specific data
    /// - `timestamp`: The time that the event occured if available or the time the message was sent if not
    ///
    fn event(&self, id: i32, event_id: &str, data: arg::Variant<Box<arg::RefArg>>, timestamp: u32) -> Result<(), Self::Err>;

    /// This is called by the applet to notify the application that it is about
    /// to show the menu under the specified item.
    ///
    /// ### Inputs
    ///
    /// - `id`: Which menu item represents the parent of the item about to be shown.
    ///
    /// ### Outputs
    ///
    /// - `need_update: bool`: Whether this AboutToShow event should result in the menu being updated.
    ///
    fn about_to_show(&self, id: i32) -> Result<bool, Self::Err>;

    // ----------- PROPERTIES

    /// Provides the version of the DBusmenu API that this API is implementing.
    ///
    /// ### Outputs
    ///
    /// - `version: u32`: The version of the DBusmenu API
    ///
    fn get_version(&self) -> Result<u32, Self::Err>;

    /// Tells if the menus are in a normal state or they believe that they
    /// could use some attention.  Cases for showing them would be if help
    /// were referring to them or they accessors were being highlighted.
    ///
    ///
    /// ### Outputs
    ///
    /// - `value: String`
    ///      - `normal`: returned in almost all cases
    ///      - `notice`: menu should have a higher priority to be shown
    ///
    fn get_status(&self) -> Result<String, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> ComCanonicalDbusmenu for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn get_layout(&self, parent_id: i32, recursion_depth: i32, property_names: Vec<&str>) -> Result<(u32, (i32, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>, Vec<arg::Variant<Box<arg::RefArg>>>)), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"com.canonical.dbusmenu".into(), &"GetLayout".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(parent_id);
            i.append(recursion_depth);
            i.append(property_names);
        }));
        try!(m.as_result());
        let mut i = m.iter_init();
        let revision: u32 = try!(i.read());
        let layout: (i32, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>, Vec<arg::Variant<Box<arg::RefArg>>>) = try!(i.read());
        Ok((revision, layout))
    }

    fn get_group_properties(&self, ids: Vec<i32>, property_names: Vec<&str>) -> Result<Vec<(i32, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)>, Self::Err> {
        let mut m = try!(self.method_call_with_args(&"com.canonical.dbusmenu".into(), &"GetGroupProperties".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(ids);
            i.append(property_names);
        }));
        try!(m.as_result());
        let mut i = m.iter_init();
        let properties: Vec<(i32, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)> = try!(i.read());
        Ok(properties)
    }

    fn get_property(&self, id: i32, name: &str) -> Result<arg::Variant<Box<arg::RefArg>>, Self::Err> {
        let mut m = try!(self.method_call_with_args(&"com.canonical.dbusmenu".into(), &"GetProperty".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(id);
            i.append(name);
        }));
        try!(m.as_result());
        let mut i = m.iter_init();
        let value: arg::Variant<Box<arg::RefArg>> = try!(i.read());
        Ok(value)
    }

    fn event(&self, id: i32, event_id: &str, data: arg::Variant<Box<arg::RefArg>>, timestamp: u32) -> Result<(), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"com.canonical.dbusmenu".into(), &"Event".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(id);
            i.append(event_id);
            i.append(data);
            i.append(timestamp);
        }));
        try!(m.as_result());
        Ok(())
    }

    fn about_to_show(&self, id: i32) -> Result<bool, Self::Err> {
        let mut m = try!(self.method_call_with_args(&"com.canonical.dbusmenu".into(), &"AboutToShow".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(id);
        }));
        try!(m.as_result());
        let mut i = m.iter_init();
        let need_update: bool = try!(i.read());
        Ok(need_update)
    }

    fn get_version(&self) -> Result<u32, Self::Err> {
        let mut m = try!(self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"Get".into(), move |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append("com.canonical.dbusmenu");
            i.append("Version");
        }));
        let v: arg::Variant<_> = try!(try!(m.as_result()).read1());
        Ok(v.0)
    }

    fn get_status(&self) -> Result<String, Self::Err> {
        let mut m = try!(self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"Get".into(), move |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append("com.canonical.dbusmenu");
            i.append("Status");
        }));
        let v: arg::Variant<_> = try!(try!(m.as_result()).read1());
        Ok(v.0)
    }
}


pub fn com_canonical_dbusmenu_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F)
-> tree::Interface<tree::MTFn<D>, D> where
D: tree::DataType, D::Method: Default,
T: ComCanonicalDbusmenu<Err=tree::MethodErr>, D::Property: Default,
F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T
{

    let i = factory.interface("com.canonical.dbusmenu", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let parent_id: i32 = try!(i.read());
        let recursion_depth: i32 = try!(i.read());
        let property_names: Vec<&str> = try!(i.read());
        let d = fclone(minfo);
        let (revision, layout) = try!(d.get_layout(parent_id, recursion_depth, property_names));
        let rm = minfo.msg.method_return();
        let rm = rm.append1(revision);
        let rm = rm.append1(layout);
        Ok(vec!(rm))
    };
    let m = factory.method("GetLayout", Default::default(), h);
    let m = m.in_arg(("parentId", "i"));
    let m = m.in_arg(("recursionDepth", "i"));
    let m = m.in_arg(("propertyNames", "as"));
    let m = m.out_arg(("revision", "u"));
    let m = m.out_arg(("layout", "(ia{sv}av)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let ids: Vec<i32> = try!(i.read());
        let property_names: Vec<&str> = try!(i.read());
        let d = fclone(minfo);
        let properties = try!(d.get_group_properties(ids, property_names));
        let rm = minfo.msg.method_return();
        let rm = rm.append1(properties);
        Ok(vec!(rm))
    };
    let m = factory.method("GetGroupProperties", Default::default(), h);
    let m = m.in_arg(("ids", "ai"));
    let m = m.in_arg(("propertyNames", "as"));
    let m = m.out_arg(("properties", "a(ia{sv})"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let id: i32 = try!(i.read());
        let name: &str = try!(i.read());
        let d = fclone(minfo);
        let value = try!(d.get_property(id, name));
        let rm = minfo.msg.method_return();
        let rm = rm.append1(value);
        Ok(vec!(rm))
    };
    let m = factory.method("GetProperty", Default::default(), h);
    let m = m.in_arg(("id", "i"));
    let m = m.in_arg(("name", "s"));
    let m = m.out_arg(("value", "v"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let id: i32 = try!(i.read());
        let event_id: &str = try!(i.read());
        let data: arg::Variant<Box<arg::RefArg>> = try!(i.read());
        let timestamp: u32 = try!(i.read());
        let d = fclone(minfo);
        try!(d.event(id, event_id, data, timestamp));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Event", Default::default(), h);
    let m = m.in_arg(("id", "i"));
    let m = m.in_arg(("eventId", "s"));
    let m = m.in_arg(("data", "v"));
    let m = m.in_arg(("timestamp", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let id: i32 = try!(i.read());
        let d = fclone(minfo);
        let need_update = try!(d.about_to_show(id));
        let rm = minfo.msg.method_return();
        let rm = rm.append1(need_update);
        Ok(vec!(rm))
    };
    let m = factory.method("AboutToShow", Default::default(), h);
    let m = m.in_arg(("id", "i"));
    let m = m.out_arg(("needUpdate", "b"));
    let i = i.add_m(m);

    let p = factory.property::<u32, _>("Version", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(try!(d.get_version()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Status", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(try!(d.get_status()));
        Ok(())
    });
    let i = i.add_p(p);
    i
}

/// Triggered when there are lots of property updates across many items
/// so they all get grouped into a single dbus message.
///
/// ### Inputs
///
/// - `conn`: Connection to the bus
/// - `updated_props`: Vec of (the ID of the item, hashtable of names and values for those properties)
///
pub fn com_canonical_dbusmenu_items_properties_updated_emit<C: ::std::ops::Deref<Target=dbus::Connection>>(conn: &dbus::ConnPath<C>, updated_props: Vec<(i32, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)>, removed_props: Vec<(i32, Vec<String>)>) -> Result<(), dbus::Error> {
    conn.signal_with_args(&"com.canonical.dbusmenu".into(), &"ItemsPropertiesUpdated".into(), move |msg| {
         let mut i = arg::IterAppend::new(msg);
         i.append(updated_props);
         i.append(removed_props);
    }).map(|_| ())
}

/// Triggered when there are lots of property updates across many items
/// so they all get grouped into a single dbus message.  The format is
/// the ID of the item with a hashtable of names and values for those
/// properties.
///
/// ### Inputs
///
/// - `conn`: Connection to the bus
/// - `revision`: The revision of the layout that we're currently on
/// - `parent`: If the layout update is only of a subtree, this is the
///         parent item for the entries that have changed.  It is zero if
///         the whole layout should be considered invalid.
///
pub fn com_canonical_dbusmenu_layout_updated_emit<C: ::std::ops::Deref<Target=dbus::Connection>>(conn: &dbus::ConnPath<C>, revision: u32, parent: i32) -> Result<(), dbus::Error> {
    conn.signal_with_args(&"com.canonical.dbusmenu".into(), &"LayoutUpdated".into(), move |msg| {
         let mut i = arg::IterAppend::new(msg);
         i.append(revision);
         i.append(parent);
    }).map(|_| ())
}

/// The server is requesting that all clients displaying this
/// menu open it to the user.  This would be for things like
/// hotkeys that when the user presses them the menu should
/// open and display itself to the user.
///
/// ### Inputs
///
/// - `conn`: Connection to the bus
/// - `id`: ID of the menu that should be activated
/// - `timestamp`: The time that the event occured
///
pub fn com_canonical_dbusmenu_item_activation_requested_emit<C: ::std::ops::Deref<Target=dbus::Connection>>(conn: &dbus::ConnPath<C>, id: i32, timestamp: u32) -> Result<(), dbus::Error> {
    conn.signal_with_args(&"com.canonical.dbusmenu".into(), &"ItemActivationRequested".into(), move |msg| {
         let mut i = arg::IterAppend::new(msg);
         i.append(id);
         i.append(timestamp);
    }).map(|_| ())
}
